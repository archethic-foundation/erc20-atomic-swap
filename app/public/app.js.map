{
  "version": 3,
  "sources": ["../client/app.js"],
  "sourcesContent": ["window.onload = async function() {\n  if (typeof window.ethereum !== \"undefined\") {\n    console.log(\"MetaMask is installed!\");\n  } else {\n    throw \"No ethereum provider is installed\";\n  }\n};\n\n$(\"#connectMetamaskBtn\").on('click', async () => {\n  provider = new ethers.providers.Web3Provider(window.ethereum);\n\n  // MetaMask requires requesting permission to connect users accounts\n  await provider.send(\"eth_requestAccounts\", []);\n\n  $(\"#main\").hide()\n  await startApp(provider);\n})\n\nasync function startApp(provider) {\n  $(\"#swapForm\").show();\n\n  const { chainId: ethChainId } = await provider.getNetwork()\n  const { archethicEndpoint, unirisTokenAddress, recipientEthereum, sufficientFunds } = await getConfig(ethChainId);\n\n  if (!sufficientFunds) {\n    $(\"#error\").text(\"An error occured: Bridge has insuffficient funds. Please retry later\")\n    $(\"#btnSwap\").hide()\n    return\n  }\n\n  const archethic = new Archethic(archethicEndpoint)\n  await archethic.connect()\n  console.log(\"Archethic endpoint: \", archethicEndpoint);\n\n  const signer = provider.getSigner();\n\n  const account = await signer.getAddress();\n  const unirisContract = await getERC20Contract(unirisTokenAddress, provider);\n\n  const balance = await unirisContract.balanceOf(account);\n  $(\"#ucoEthBalance\").text(ethers.utils.formatUnits(balance, 18))\n\n  $(\"#recipientAddress\").on(\"change\", async (e) => {\n    const archethicBalance = await getLastTransactionBalance(archethic, $(e.target).val())\n    $(\"#ucoArchethicBalance\").text(archethicBalance / 1e8)\n  })\n\n  $(\"#swapForm\").on('submit', async (e) => {\n    e.preventDefault();\n    if (!e.target.checkValidity()) {\n      return;\n    }\n\n    const recipientAddress = $(\"#recipientAddress\").val();\n    await handleFormSubmit(signer, unirisContract, recipientEthereum, recipientAddress, ethChainId, archethic);\n  })\n}\n\nasync function getERC20Contract(unirisTokenAddress, provider) {\n  const unirisTokenABI = await getUnirisTokenABI();\n  return new ethers.Contract(unirisTokenAddress, unirisTokenABI, provider);\n}\n\nasync function handleFormSubmit(signer, unirisContract, recipientEthereum, recipientArchethic, ethChainId, archethic) {\n  $(\"#progressBar\").show()\n\n  const secret = new Uint8Array(32);\n  crypto.getRandomValues(secret);\n\n  const secretHex = uint8ArrayToHex(secret);\n\n  let secretDigest = await crypto.subtle.digest(\"SHA-256\", secret);\n  secretDigest = new Uint8Array(secretDigest);\n\n  const secretDigestHex = uint8ArrayToHex(secretDigest);\n\n  const amount = $(\"#nbTokensToSwap\").val();\n\n  try {\n\n    $(\"#deployEthProgress\").css({ color: \"white\" })\n\n    const HTLC_Contract = await deployHTLC(\n      recipientEthereum,\n      unirisContract.address,\n      amount,\n      secretDigest,\n      signer,\n      10000\n    );\n\n    const HTLCAddress = HTLC_Contract.address;\n\n    await transferTokensToHTLC(amount, HTLCAddress, unirisContract, signer)\n\n    $(\"#deployEthProgress\").css({ color: \"greenyellow\" })\n    $(\"#deployArchethicProgress\").css({ color: \"white\" })\n\n    const contractAddress = await sendDeployRequest(\n      secretDigestHex,\n      recipientArchethic,\n      amount,\n      HTLCAddress,\n      ethChainId\n    );\n    console.log(\"Contract address on Archethic\", contractAddress);\n\n    $(\"#deployArchethicProgress\").css({ color: \"greenyellow\" })\n    await sendWithdrawRequest(contractAddress, HTLCAddress, secretHex, ethChainId);\n    console.log(\"Token swap finish\");\n\n    $(\"#swapProgress\").css({ color: \"greenyellow\" })\n    $(\"#swapValidated\").css({ color: \"greenyellow\" })\n\n    const archethicBalance = await getLastTransactionBalance(archethic, recipientArchethic)\n    $(\"#ucoArchethicBalance\").text(archethicBalance / 1e8)\n\n  } catch (e) {\n    console.error(e.message || e);\n    $(\"#error\").text(`An error occured: ${e.message || e}`).show()\n  }\n}\n\nasync function sendDeployRequest(secretDigestHex, recipientAddress, amount, ethereumContractAddress, ethChainId) {\n  const endTime = new Date();\n  endTime.setSeconds(endTime.getSeconds() + 10000);\n  const endTimeUNIX = Math.floor(endTime / 1000);\n\n  return fetch(\"/swap/deployContract\", {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      secretHash: secretDigestHex,\n      recipientAddress: recipientAddress,\n      amount: amount * 1e8,\n      endTime: endTimeUNIX,\n      ethereumContractAddress: ethereumContractAddress,\n      ethereumChainId: ethChainId\n    }),\n  })\n    .then(handleResponse)\n    .then((r) => r.contractAddress);\n}\n\nasync function sendWithdrawRequest(archethicContractAddress, ethereumContractAddress, secret, ethChainId) {\n  return fetch(\"/swap/withdraw\", {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      archethicContractAddress: archethicContractAddress,\n      ethereumContractAddress: ethereumContractAddress,\n      secret: secret,\n      ethereumChainId: ethChainId\n    }),\n  })\n    .then(handleResponse)\n}\n\nasync function deployHTLC(\n  recipientEthereum,\n  unirisTokenAddress,\n  amount,\n  hash,\n  signer,\n  lockTime\n) {\n  const { abi: HTLCABI, bytecode: HTLCByteCode } = await getHTLC();\n  const factory = new ethers.ContractFactory(HTLCABI, HTLCByteCode, signer);\n\n  const contract = await factory.deploy(\n    recipientEthereum,\n    unirisTokenAddress,\n    ethers.utils.parseUnits(amount, 18),\n    hash, lockTime, { gasLimit: 1000000 }\n  );\n\n  await contract.deployTransaction.wait();\n  console.log(\"HTLC contract deployed at \" + contract.address);\n\n  return contract;\n}\n\nasync function transferTokensToHTLC(\n  amount,\n  HTLCAddress,\n  unirisContract,\n  signer\n) {\n  const unirisWithSigner = unirisContract.connect(signer);\n\n  await unirisWithSigner.transfer(\n    HTLCAddress,\n    ethers.utils.parseUnits(amount, 18)\n  );\n  const filter = unirisContract.filters.Transfer(null, HTLCAddress);\n\n  return new Promise((resolve, _reject) => {\n    unirisContract.on(filter, (_from, _to, amount, _event) => {\n      console.log(ethers.utils.formatUnits(amount, 18) + \" UCO transfered\");\n      resolve();\n    });\n  });\n}\n\nconst byteToHex = [];\nfor (let n = 0; n <= 0xff; ++n) {\n  const hexOctet = n.toString(16).padStart(2, \"0\");\n  byteToHex.push(hexOctet);\n}\n\nfunction uint8ArrayToHex(bytes) {\n  const buff = new Uint8Array(bytes);\n  const hexOctets = new Array(buff.length);\n\n  for (let i = 0; i < buff.length; ++i) {\n    hexOctets[i] = byteToHex[buff[i]];\n  }\n\n  return hexOctets.join(\"\");\n}\n\nasync function getConfig(ethChainId) {\n  return fetch(\"/status\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\",\n    },\n    body: JSON.stringify({\n      ethereumChainId: ethChainId\n    })\n  })\n    .then(handleResponse)\n    .then((r) => {\n      return {\n        archethicEndpoint: r.archethicEndpoint,\n        unirisTokenAddress: r.unirisTokenAddress,\n        recipientEthereum: r.recipientEthereum,\n        sufficientFunds: r.sufficientFunds\n      };\n    });\n}\n\nasync function getUnirisTokenABI() {\n  const r = await fetch(\"uco_ABI.json\");\n  return await r.json();\n}\n\nasync function getHTLC() {\n  const r = await fetch(\"HTLC.json\");\n  const r_1 = await r.json();\n  return {\n    abi: r_1.abi,\n    bytecode: r_1.bytecode,\n  };\n}\n\nasync function getArchethicBalance(archethic, address) {\n\n  archethic.requestNode(async (endpoint) => {\n    const url = new URL(\"/api\", endpoint);\n    const r = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n      },\n      body: JSON.stringify({\n        query: `\n          query {\n            balance(address: \"${address}\") {\n              uco\n            }\n          }\n        `\n      })\n    });\n    const res = await r.json();\n    if (res.data.balance && res.data.balance.uco) {\n      return res.data.balance.uco;\n    }\n    return 0;\n  })\n}\n\n\nasync function getLastTransactionBalance(archethic, address) {\n  return archethic.requestNode(async (endpoint) => {\n    const url = new URL(\"/api\", endpoint);\n    const r = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n      },\n      body: JSON.stringify({\n        query: `\n            query {\n              lastTransaction(address: \"${address}\") {\n                 balance {\n                   uco\n                 }\n              }\n            }\n          `\n      })\n    });\n    const res = await r.json();\n\n    if (res.errors && res.errors.find(x => x.message == \"transaction_not_exists\")) {\n      return await getInputs(archethic, address)\n    }\n\n    if (res.data.lastTransaction && res.data.lastTransaction.balance) {\n      return res.data.lastTransaction.balance.uco;\n    }\n\n    return 0;\n  })\n}\n\nasync function getInputs(archethic, address) {\n  return archethic.requestNode(async (endpoint) => {\n    const url = new URL(\"/api\", endpoint);\n    const r = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n      },\n      body: JSON.stringify({\n        query: `\n            query {\n              transactionInputs(address: \"${address}\") {\n                 type,\n                 amount\n              }\n            }\n          `\n      })\n    });\n    const res = await r.json();\n    if (res.data.transactionInputs && res.data.transactionInputs.length > 0) {\n      return res.data.transactionInputs\n        .filter(r => r.type == \"UCO\")\n        .reduce((acc, { amount: amount }) => acc + amount, 0)\n    }\n    return 0;\n  })\n}\n\nasync function handleResponse(response) {\n  return new Promise(function(resolve, reject) {\n    if (response.status >= 200 && response.status <= 299) {\n      response.json().then(resolve);\n    } else {\n      response.json()\n        .then(reject)\n        .catch(() => reject(response.statusText))\n    }\n  });\n}"],
  "mappings": "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",
  "names": ["startApp", "provider", "ethChainId", "archethicEndpoint", "unirisTokenAddress", "recipientEthereum", "sufficientFunds", "getConfig", "archethic", "signer", "account", "unirisContract", "getERC20Contract", "balance", "e", "archethicBalance", "getLastTransactionBalance", "recipientAddress", "handleFormSubmit", "unirisTokenABI", "getUnirisTokenABI", "recipientArchethic", "secret", "secretHex", "uint8ArrayToHex", "secretDigest", "secretDigestHex", "amount", "HTLCAddress", "deployHTLC", "transferTokensToHTLC", "contractAddress", "sendDeployRequest", "sendWithdrawRequest", "ethereumContractAddress", "endTime", "endTimeUNIX", "handleResponse", "r", "archethicContractAddress", "hash", "lockTime", "HTLCABI", "HTLCByteCode", "getHTLC", "contract", "filter", "resolve", "_reject", "_from", "_to", "_event", "byteToHex", "n", "hexOctet", "bytes", "buff", "hexOctets", "i", "r_1", "getLastTransactionBalance", "archethic", "address", "endpoint", "url", "res", "x", "getInputs", "acc", "amount", "handleResponse", "response", "resolve", "reject"]
}
