(()=>{window.onload=async function(){if(typeof window.ethereum<"u")console.log("MetaMask is installed!"),provider=new ethers.providers.Web3Provider(window.ethereum),await b(provider).then(async t=>{t?await C(provider):$("#connectingWallet").show()});else throw"No ethereum provider is installed"};$("#connectMetamaskBtn").on("click",async()=>{try{provider=new ethers.providers.Web3Provider(window.ethereum),await provider.send("eth_requestAccounts",[]),await C(provider)}catch(t){$("#error").text(`An error occured: ${t.message||t}`).show()}});var b=async t=>(await t.listAccounts()).length>0;async function C(t){let{chainId:e}=await t.getNetwork(),n=t.getSigner(),a;switch(e){case 137:a="Polygon-logo.svg";break;case 56:a="BSC-logo.svg";break;default:a="Ethereum-logo.svg";break}let{archethicEndpoint:r,unirisTokenAddress:s,recipientEthereum:o,sufficientFunds:i,UCOPrice:d}=await x(e);if($("#sourceChainImg").attr("src",`assets/images/bc-logos/${a}`),$("#main").hide(),$("#swapForm").show(),$("#ucoPrice").text(`1 UCO = ${d}$`).show(),$("#swapBalanceUSD").text(d),!i){$("#error").text("An error occured: Bridge has insuffficient funds. Please retry later");return}let c=new Archethic(r);await c.connect(),console.log("Archethic endpoint: ",r);let w=await n.getAddress(),l=await S(s,t),h=await l.balanceOf(w),p=ethers.utils.formatUnits(h,18);$("#fromBalanceUCO").text(p),$("#fromBalanceUSD").text(p*d),$("#recipientAddress").on("change",async u=>{let y=await A(c,$(u.target).val())/1e8;$("#toBalanceUCO").text(y),$("#toBalanceUSD").text(d*y)}),$("#nbTokensToSwap").on("change",u=>{let f=$(u.target).val();$("#swapBalanceUSD").text(f*d)}),$("#btnSwap").show(),$("#swapForm").on("submit",async u=>{if(u.preventDefault(),!u.target.checkValidity())return;let f=$("#recipientAddress").val();await U(n,l,o,f,e,c,d)})}async function S(t,e){let n=await k();return new ethers.Contract(t,n,e)}async function U(t,e,n,a,r,s,o){$("#steps").show();let i=new Uint8Array(32);crypto.getRandomValues(i);let d=m(i),c=await crypto.subtle.digest("SHA-256",i);c=new Uint8Array(c);let w=m(c),l=$("#nbTokensToSwap").val();$("#connectingStep").addClass("is-active");try{let p=(await B(n,e.address,l,c,t,1e4)).address;await j(l,p,e,t);let u=await v(w,a,l,p,r);console.log("Contract address on Archethic",u),$("#connectingStep").removeClass("is-active"),$("#swapStep").addClass("is-active"),await O(u,p,d,r),console.log("Token swap finish");let y=await A(s,a)/1e8;$("#toBalanceUCO").text(y),$("#toBalanceUSD").text(o*y),$("#swapStep").removeClass("is-active"),$("#endPhase").addClass("is-active")}catch(h){console.error(h.message||h),$("#error").text(`An error occured: ${h.message||h}`).show()}}async function v(t,e,n,a,r){let s=new Date;s.setSeconds(s.getSeconds()+1e4);let o=Math.floor(s/1e3);return fetch("/swap/deployContract",{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({secretHash:t,recipientAddress:e,amount:n*1e8,endTime:o,ethereumContractAddress:a,ethereumChainId:r})}).then(g).then(i=>i.contractAddress)}async function O(t,e,n,a){return fetch("/swap/withdraw",{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({archethicContractAddress:t,ethereumContractAddress:e,secret:n,ethereumChainId:a})}).then(g)}async function B(t,e,n,a,r,s){let{abi:o,bytecode:i}=await P(),c=await new ethers.ContractFactory(o,i,r).deploy(t,e,ethers.utils.parseUnits(n,18),a,s,{gasLimit:1e6});return await c.deployTransaction.wait(),console.log("HTLC contract deployed at "+c.address),c}async function j(t,e,n,a){await n.connect(a).transfer(e,ethers.utils.parseUnits(t,18));let s=n.filters.Transfer(null,e);return new Promise((o,i)=>{n.on(s,(d,c,w,l)=>{console.log(ethers.utils.formatUnits(w,18)+" UCO transfered"),o()})})}var T=[];for(let t=0;t<=255;++t){let e=t.toString(16).padStart(2,"0");T.push(e)}function m(t){let e=new Uint8Array(t),n=new Array(e.length);for(let a=0;a<e.length;++a)n[a]=T[e[a]];return n.join("")}async function x(t){return fetch("/status",{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({ethereumChainId:t})}).then(g).then(e=>{if(e.status!="ok")throw e.status;return{archethicEndpoint:e.archethicEndpoint,unirisTokenAddress:e.unirisTokenAddress,recipientEthereum:e.recipientEthereum,sufficientFunds:e.sufficientFunds,UCOPrice:e.UCOPrice}})}async function k(){return await(await fetch("uco_ABI.json")).json()}async function P(){let e=await(await fetch("HTLC.json")).json();return{abi:e.abi,bytecode:e.bytecode}}async function A(t,e){return t.requestNode(async n=>{let a=new URL("/api",n),s=await(await fetch(a,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:`
            query {
              lastTransaction(address: "${e}") {
                 balance {
                   uco
                 }
              }
            }
          `})})).json();return s.errors&&s.errors.find(o=>o.message=="transaction_not_exists")?await H(t,e):s.data.lastTransaction&&s.data.lastTransaction.balance?s.data.lastTransaction.balance.uco:0})}async function H(t,e){return t.requestNode(async n=>{let a=new URL("/api",n),s=await(await fetch(a,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:`
            query {
              transactionInputs(address: "${e}") {
                 type,
                 amount
              }
            }
          `})})).json();return s.data.transactionInputs&&s.data.transactionInputs.length>0?s.data.transactionInputs.filter(o=>o.type=="UCO").reduce((o,{amount:i})=>o+i,0):0})}async function g(t){return new Promise(function(e,n){t.status>=200&&t.status<=299?t.json().then(e):t.json().then(n).catch(()=>n(t.statusText))})}})();
//# sourceMappingURL=app.js.map
