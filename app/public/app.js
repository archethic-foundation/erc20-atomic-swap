(()=>{window.onload=async function(){if(typeof window.ethereum<"u")console.log("MetaMask is installed!");else throw"No ethereum provider is installed"};$("#connectMetamaskBtn").on("click",async()=>{try{provider=new ethers.providers.Web3Provider(window.ethereum),await provider.send("eth_requestAccounts",[]),await A(provider)}catch(e){$("#error").text(`An error occured: ${e.message||e}`).show()}});async function A(e){let{chainId:t}=await e.getNetwork(),n=e.getSigner(),a;switch(t){case 137:a="Polygon-logo.svg";break;case 56:a="BSC-logo.svg";break;default:a="Ethereum-logo.svg";break}let{archethicEndpoint:r,unirisTokenAddress:s,recipientEthereum:o,sufficientFunds:i,UCOPrice:d}=await x(t);if($("#sourceChainImg").attr("src",`assets/images/bc-logos/${a}`),$("#main").hide(),$("#swapForm").show(),$("#ucoPrice").text(`1 UCO = ${d}$`).show(),$("#swapBalanceUSD").text(d),!i){$("#error").text("An error occured: Bridge has insuffficient funds. Please retry later");return}let c=new Archethic(r);await c.connect(),console.log("Archethic endpoint: ",r);let f=await n.getAddress(),l=await b(s,e),h=await l.balanceOf(f),p=ethers.utils.formatUnits(h,18);$("#fromBalanceUCO").text(p),$("#fromBalanceUSD").text(p*d),$("#recipientAddress").on("change",async u=>{let y=await T(c,$(u.target).val())/1e8;$("#toBalanceUCO").text(y),$("#toBalanceUSD").text(d*y)}),$("#nbTokensToSwap").on("change",u=>{let w=$(u.target).val();$("#swapBalanceUSD").text(w*d)}),$("#btnSwap").show(),$("#swapForm").on("submit",async u=>{if(u.preventDefault(),!u.target.checkValidity())return;let w=$("#recipientAddress").val();await S(n,l,o,w,t,c,d)})}async function b(e,t){let n=await v();return new ethers.Contract(e,n,t)}async function S(e,t,n,a,r,s,o){$("#steps").show();let i=new Uint8Array(32);crypto.getRandomValues(i);let d=m(i),c=await crypto.subtle.digest("SHA-256",i);c=new Uint8Array(c);let f=m(c),l=$("#nbTokensToSwap").val();$("#connectingStep").addClass("is-active");try{let p=(await B(n,t.address,l,c,e,1e4)).address;await j(l,p,t,e);let u=await U(f,a,l,p,r);console.log("Contract address on Archethic",u),$("#connectingStep").removeClass("is-active"),$("#swapStep").addClass("is-active"),await O(u,p,d,r),console.log("Token swap finish");let y=await T(s,a)/1e8;$("#toBalanceUCO").text(y),$("#toBalanceUSD").text(o*y),$("#swapStep").removeClass("is-active"),$("#endPhase").addClass("is-active")}catch(h){console.error(h.message||h),$("#error").text(`An error occured: ${h.message||h}`).show()}}async function U(e,t,n,a,r){let s=new Date;s.setSeconds(s.getSeconds()+1e4);let o=Math.floor(s/1e3);return fetch("/swap/deployContract",{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({secretHash:e,recipientAddress:t,amount:n*1e8,endTime:o,ethereumContractAddress:a,ethereumChainId:r})}).then(g).then(i=>i.contractAddress)}async function O(e,t,n,a){return fetch("/swap/withdraw",{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({archethicContractAddress:e,ethereumContractAddress:t,secret:n,ethereumChainId:a})}).then(g)}async function B(e,t,n,a,r,s){let{abi:o,bytecode:i}=await k(),c=await new ethers.ContractFactory(o,i,r).deploy(e,t,ethers.utils.parseUnits(n,18),a,s,{gasLimit:1e6});return await c.deployTransaction.wait(),console.log("HTLC contract deployed at "+c.address),c}async function j(e,t,n,a){await n.connect(a).transfer(t,ethers.utils.parseUnits(e,18));let s=n.filters.Transfer(null,t);return new Promise((o,i)=>{n.on(s,(d,c,f,l)=>{console.log(ethers.utils.formatUnits(f,18)+" UCO transfered"),o()})})}var C=[];for(let e=0;e<=255;++e){let t=e.toString(16).padStart(2,"0");C.push(t)}function m(e){let t=new Uint8Array(e),n=new Array(t.length);for(let a=0;a<t.length;++a)n[a]=C[t[a]];return n.join("")}async function x(e){return fetch("/status",{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({ethereumChainId:e})}).then(g).then(t=>{if(t.status!="ok")throw t.status;return{archethicEndpoint:t.archethicEndpoint,unirisTokenAddress:t.unirisTokenAddress,recipientEthereum:t.recipientEthereum,sufficientFunds:t.sufficientFunds,UCOPrice:t.UCOPrice}})}async function v(){return await(await fetch("uco_ABI.json")).json()}async function k(){let t=await(await fetch("HTLC.json")).json();return{abi:t.abi,bytecode:t.bytecode}}async function T(e,t){return e.requestNode(async n=>{let a=new URL("/api",n),s=await(await fetch(a,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:`
            query {
              lastTransaction(address: "${t}") {
                 balance {
                   uco
                 }
              }
            }
          `})})).json();return s.errors&&s.errors.find(o=>o.message=="transaction_not_exists")?await P(e,t):s.data.lastTransaction&&s.data.lastTransaction.balance?s.data.lastTransaction.balance.uco:0})}async function P(e,t){return e.requestNode(async n=>{let a=new URL("/api",n),s=await(await fetch(a,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:`
            query {
              transactionInputs(address: "${t}") {
                 type,
                 amount
              }
            }
          `})})).json();return s.data.transactionInputs&&s.data.transactionInputs.length>0?s.data.transactionInputs.filter(o=>o.type=="UCO").reduce((o,{amount:i})=>o+i,0):0})}async function g(e){return new Promise(function(t,n){e.status>=200&&e.status<=299?e.json().then(t):e.json().then(n).catch(()=>n(e.statusText))})}})();
//# sourceMappingURL=app.js.map
